public class Dijkstra {

  public Path dijkstra(City source, City destination) {
    DynamicArray<Path> data = new DynamicArray<>();
    QPrior<Path> queue = new QPrior<>();
    Path start = new Path(source, null, 0);
    queue.enqueue(start);
    while (queue.isEmpty() == false) {
        Path currentPath = queue.dequeue();
        // If we've reached the destination, return the path
        if (currentPath.getCity().name.equals(destination.name)) {
            return currentPath;
        }
        //System.out.println("Visted: " + currentPath.getCity().name);
        // Ensure array has enough capacity for current city's ID
        while (data.getSize() <= currentPath.getCity().id) {
            data.add(null);
        }
        // Check if we've already recorded the shortest path to this city
        if (data.get(currentPath.getCity().id) == null || data.get(currentPath.getCity().id).getDist() > currentPath.getDist()) {
            data.set(currentPath.getCity().id, currentPath);
            for (Connection conn : currentPath.getCity().connections) {
                City connCity = conn.getDest();
                Integer totalDist = currentPath.getDist() + conn.duration;
                Path connPath = new Path(connCity, currentPath.getCity(), totalDist);
                // Ensure array has enough capacity for connCity's ID
                while (data.getSize() <= connCity.id) {
                    data.add(null);
                }
                // Only enqueue if we haven't found a shorter path already
                if (data.get(connCity.id) == null || data.get(connCity.id).getDist() > totalDist) {
                    queue.enqueue(connPath);
                    //System.out.println("New Path: " + currentPath.getCity().name + " -> " + conn.getDest().name + " : " + totalDist);
                }
            }
        }
    }
    return null;
}





}





import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class Dijkstra {
    private DynamicArray<Path> data;

 public Path dijkstra(City source, City destination) {
    data = new DynamicArray<>();
    QPrior<Path> queue = new QPrior<>();
    Path start = new Path(source, null, 0);
    queue.enqueue(start);
    
    while (!queue.isEmpty()) {
        Path currentPath = queue.dequeue();
        if (currentPath.getCity().name.equals(destination.name)) {
            return currentPath;
        }
        
        while (data.getSize() <= currentPath.getCity().id) {
            data.add(null);
        }
        
        if (data.get(currentPath.getCity().id) == null || 
            data.get(currentPath.getCity().id).getDist() > currentPath.getDist()) {
            data.set(currentPath.getCity().id, currentPath);
            
            for (Connection conn : currentPath.getCity().connections) {
                City connCity = conn.getDest();
                Integer totalDist = currentPath.getDist() + conn.duration;
                Path connPath = new Path(connCity, currentPath.getCity(), totalDist);
                
                while (data.getSize() <= connCity.id) {
                    data.add(null);
                }
                
                if (data.get(connCity.id) == null || 
                    data.get(connCity.id).getDist() > totalDist) {
                    queue.enqueue(connPath);
                    // Print only when confirming the shortest path to connCity
                    printPartialPath(connPath);
                }
            }
        }
    }
    return null;
}


    public void printFullPath(Path destinationPath) {
        List<String> path = new ArrayList<>();
        for (Path current = destinationPath; current != null; current = findPathForCity(current.getCity().id)) {
            path.add(current.getCity().name);
        }
        Collections.reverse(path);
        System.out.println("Path: " + String.join(" -> ", path) + " (Total Distance: " + destinationPath.getDist() + ")");
    }

    private Path findPathForCity(int cityId) {
        return data.get(cityId);
    }

    private void printPartialPath(Path path) {
        List<String> partialPath = new ArrayList<>();
        for (Path current = path; current != null; current = findPathForCity(current.getCity().id)) {
            partialPath.add(current.getCity().name);
        }
        Collections.reverse(partialPath);
        System.out.println("Partial Path: " + String.join(" -> ", partialPath));
    }
}
